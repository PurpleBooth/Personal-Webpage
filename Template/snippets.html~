<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" >
  <head>
    <link rel="stylesheet" type="text/css" href="fonts.css" />
    <link rel="stylesheet" type="text/css" href="main.css" />
    <title>Will Booth</title>
<script language="javascript">
<!--
function pphWxKAcDsqUOUy()
{
var zAwtVcPVJIbKPkA=["x77","105","108","108","x2e","119","x65","98","64","115","111","x6c","x61","99","101","x2d","115","x79","x73","x74","101","109","46","x63","111","x2e","x75","107"];
var LzEdrkCQLsfZWGD=[" "];
var wozaQWiCZfakxUk=["x77","x69","108","108","46","119","x65","98","64","x73","x6f","x6c","x61","99","101","x2d","x73","x79","115","116","101","x6d","x2e","99","x6f","46","117","x6b"];
document.write("<a href=\"&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;");
for (i=0; i<zAwtVcPVJIbKPkA.length; i++) document.write("&#"+zAwtVcPVJIbKPkA[i]+";");
for (i=0; i<LzEdrkCQLsfZWGD.length; i++) document.write(LzEdrkCQLsfZWGD[i]);
document.write("\">");
for (i=0; i<wozaQWiCZfakxUk.length; i++) document.write("&#"+wozaQWiCZfakxUk[i]+";");
document.write('</a>');
}
//-->
</script>
  </head>
  <body>
  	<div id="logo" >
  		<img alt="Will Booth" src="Logo.png" />
  	</div>
   	   	<ul id="menu">
   		<li id="menu_unselected_left"><a class="menu" href="index.html">About</a></li> 
   		<li class="menu_selected"><a class="menu" href="snippets.html">Snippets</a></li>
   		<li id="menu_unselected_right"><a class="menu" href="#template">Lectures</a></li>
   	</ul>
   	<div class="clear_both">&nbsp;</div>
    <div id="body">
    	<h1>Snippets</h1>
    	<h2>Josephus Circle</h2>
<p>In computer science and mathematics, the Josephus problem (or Josephus permutation) is a theoretical problem related to a certain counting-out game.</p>
<p>There are people standing in a circle waiting to be executed. After the first man is executed, certain number of people are skipped and one man is executed. Then again, people are skipped and a man is executed. The elimination proceeds around the circle (which is becoming smaller and smaller as the executed people are removed), until only the last man remains, who is given freedom.</p>
<p>The task is to choose the place in the initial circle so that you survive (are the last one remaining).</p>
    	<div class="code">#!/usr/bin/python<br />
<br />
import unittest<br />
<br />
class groupOfMen:<br />
<br />
	number_of_men = 0<br />
<br />
	def __init__(self, number_of_men):<br />
		self.number_of_men = number_of_men<br />
<br />
	def josephusSuicide(self, man_to_skip):<br />
		man_to_skip = man_to_skip + 1<br />
		men = []<br />
		surviving_men = range(1, self.number_of_men+1)<br />
				<br />
		itteration = 1<br />
		<br />
		while len(surviving_men) &gt; 1:<br />
			men = surviving_men<br />
			surviving_men = []<br />
			<br />
			while len(men) &gt; 0:<br />
				current_man = men.pop(0)<br />
				<br />
				if (itteration % man_to_skip) != 0:<br />
					surviving_men.append(current_man)<br />
					<br />
				itteration = itteration + 1<br />
			<br />
		return surviving_men.pop()<br />
<br />
class TestgroupOfMen(unittest.TestCase):<br />
	def testjosephusSuicideGifDemo(self):<br />
		group_of_men = groupOfMen(12)<br />
		self.assertEqual(10, group_of_men.josephusSuicide(2)<br />)	
		<br />
	def testjosephusSuicideStory(self):<br />
		group_of_men = groupOfMen(41)<br />
		self.assertEqual(31, group_of_men.josephusSuicide(2))	<br />
<br />
if __name__ == '__main__':<br />
    unittest.main()</div>
    <h2>Russian Peasant Multiplication</h2>
    <p>You don't need multiplication facts to use the Russian peasant algorithm; you only need to double numbers, cut them in half, and add them up. Here are the rules:</p>
<ul>
    <li> Write each number at the head of a column.
    <li> Double the number in the first column, and halve the number in the second column.</li>
    <li>     If the number in the second column is odd, divide it by two and drop the remainder.</li>
    <li> If the number in the second column is even, cross out that entire row.</li>
    <li> Keep doubling, halving, and crossing out until the number in the second column is 1.</li>
    <li> Add up the remaining numbers in the first column. The total is the product of your original numbers. </li>
</ul>
    <div class="code">#!/usr/bin/python<br />
<br />
import unittest<br />
<br />
class RussianInteger:<br />
<br />
	def __init__(self, number):<br />
		self.value = number<br />
<br />
	def multiply(self, number):<br />
		number_two = self.value<br />
		adjustment = 0<br />
<br />
		while number_two &gt; 1:<br />
			print str(number)  + &quot; &quot;+ str(number_two)<br />
			if number_two % 2 != 0:<br />
				adjustment = adjustment + number<br />
			number = number * 2<br />
			number_two = number_two // 2<br />
<br />
		print str(number)  + &quot; &quot;+ str(number_two)<br />
		print <br />
<br />
		number = number + adjustment<br />
<br />
		return number<br />
<br />
class TestRussianInteger(unittest.TestCase):<br />
	def testTwoTimesNine(self):<br />
		russian_integer_one = RussianInteger(2)<br />
		self.assertEqual(18, russian_integer_one.multiply(9))	<br />
<br />
	def testThreeTimesSeven(self):<br />
		russian_integer_one = RussianInteger(3)<br />
		self.assertEqual(21, russian_integer_one.multiply(7))	<br />
<br />
	def testEighteenTimesTwentyThree(self):<br />
		russian_integer_one = RussianInteger(18)<br />
		self.assertEqual(414, russian_integer_one.multiply(23))<br />
<br />
if __name__ == '__main__':<br />
    unittest.main()</div>

    </div>
    <div id="footer">Copyright William Alan Booth 2009 &copy;</div>
  </body>
</html>
